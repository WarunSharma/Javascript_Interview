
# Database Basics (SQL + NoSQL Schema Design)

## 1. SQL (Relational Databases)
Examples: MySQL, PostgreSQL, Oracle, SQL Server

### ✅ Characteristics
- **Structured data** stored in **tables (rows + columns)**
- Schema is **strictly defined** (columns, types, constraints)
- Supports **ACID transactions** (Atomicity, Consistency, Isolation, Durability)
- Best for: systems requiring **consistency, relationships, structured queries**

### ✅ Schema Design Example (E-commerce)
**Tables**:
- `users(id, name, email, passwordHash)`
- `products(id, name, price, stock)`
- `orders(id, user_id, created_at, status)`
- `order_items(order_id, product_id, quantity)`

**Relationships**:
- `users (1) → (many) orders`
- `orders (1) → (many) order_items`
- `products (1) → (many) order_items`

```sql
CREATE TABLE orders (
  id SERIAL PRIMARY KEY,
  user_id INT REFERENCES users(id),
  created_at TIMESTAMP DEFAULT NOW(),
  status VARCHAR(20)
);

CREATE TABLE order_items (
  order_id INT REFERENCES orders(id),
  product_id INT REFERENCES products(id),
  quantity INT,
  PRIMARY KEY (order_id, product_id)
);
```

✅ Advantages: strong consistency, relational joins, transactions  
❌ Drawbacks: rigid schema, scaling horizontally is harder  

---

## 2. NoSQL (Non-relational Databases)
Examples: MongoDB, Cassandra, DynamoDB, Couchbase

### ✅ Characteristics
- Schema is **flexible / dynamic**
- Data stored as **documents (JSON-like), key-value, wide-column, or graph**
- Prioritizes **scalability & performance**
- Often **eventually consistent** (not always strict ACID)
- Best for: **large-scale, unstructured, high-traffic applications**

### ✅ Schema Design Example (E-commerce, MongoDB)
Instead of multiple tables, embed related data:

**Collection: `orders`**
```json
{
  "orderId": 1001,
  "user": {
    "id": 1,
    "name": "Alice"
  },
  "items": [
    { "productId": 101, "name": "Laptop", "price": 1000, "quantity": 1 },
    { "productId": 102, "name": "Mouse", "price": 25, "quantity": 2 }
  ],
  "status": "shipped",
  "createdAt": "2025-10-02T09:00:00Z"
}
```

✅ Advantages: flexible schema, faster queries for nested data, easy scaling  
❌ Drawbacks: potential data duplication, less consistency guarantees  

---

## 3. SQL vs NoSQL — When to Use

| Aspect              | SQL (Relational)                 | NoSQL (Non-relational)                  |
|---------------------|-----------------------------------|------------------------------------------|
| **Schema**          | Fixed, well-defined              | Flexible, dynamic                        |
| **Data Model**      | Tables with rows & columns       | JSON docs, key-value, wide-column, graph |
| **Consistency**     | Strong (ACID transactions)       | Often eventual consistency (BASE)        |
| **Scaling**         | Vertical (bigger server)         | Horizontal (sharding/replication)        |
| **Best For**        | Financial systems, ERP, CRM      | Social networks, IoT, real-time analytics|

---

## 4. Schema Design Best Practices

### For SQL:
- Normalize to reduce redundancy (3NF)  
- Use foreign keys & constraints for data integrity  
- Index frequently queried fields  
- Use transactions for multi-step updates  

### For NoSQL:
- **Design around queries** (denormalize if needed)  
- Embed related data if queried together often  
- Use references if data changes frequently  
- Shard collections for scalability  
- Avoid unbounded arrays  

---

## 5. Hybrid Approach
Many modern apps use **both**:
- **SQL** for transactional, relational data (users, payments)  
- **NoSQL** for unstructured, high-volume, or flexible data (logs, events, sessions, analytics)  

Example:  
- **PostgreSQL** stores users, orders, payments  
- **MongoDB / ElasticSearch** stores activity feeds, logs, or search indices  

---

## Quick Recap
- **SQL** = structured, relational, strong consistency  
- **NoSQL** = flexible, scalable, high-performance, eventual consistency  
- **Schema design** depends on query patterns & use case  
- In interviews: always justify schema choices by trade-offs (consistency vs scalability, normalization vs denormalization)  
