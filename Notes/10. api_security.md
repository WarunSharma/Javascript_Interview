# API Security Best Practices

A concise checklist of practical measures to secure APIs. Focus on prevention, detection, and resilience: throttle abuse, verify identity, validate input, encrypt traffic, monitor activity, and plan for incident response.

## Rate Limiting (and Throttling)

Purpose: Prevent brute-force and DDoS attacks, protect backend resources, and enforce fair usage.

- Scope options
  - Per IP address: good default for public endpoints.
  - Per user/API key/client-id: better for authenticated APIs — prevents single-user overuse.
  - Per endpoint/resource: protect expensive operations (search, export).
  - Global quotas: daily/monthly caps for paid tiers.

- Algorithms
  - Token Bucket  

- Practical tips
  - Prefer per-user / per-api-key limits for authenticated APIs.
  - Protect login, password-reset, and OTP endpoints with stricter limits.
  - Differentiate anonymous vs authenticated users.
  - Log 429s and alert on spikes — they often indicate attacks or misbehaving clients.
  - Consider adaptive limits (lower threshold during attack or when system load is high).

## Throttling vs Rate Limiting
- Rate limiting: deny requests once a rate is exceeded (e.g., 100 requests/min).
- Throttling: intentionally slow down responses (add latency) to manage load without outright denying all requests.
- Both can be used together (throttle when load is medium, rate-limit when load is critical).

## Authentication & Authorization

- Require strong authentication for any non-public API (OAuth2, mutual-TLS, API keys).
- Use short-lived tokens (access tokens) and refresh tokens.
- Enforce scopes/permissions per endpoint.
- For microservices, prefer mTLS or JWTs validated at the gateway/service mesh layer.
- Protect credential endpoints (login, token refresh) with stricter rate limits and additional heuristics (CAPTCHA, device fingerprinting).

## Input Validation & Output Encoding

- Validate all inputs server-side: size, type, schema, allowed characters.
- Use strict JSON schema validation (AJV, Joi, Zod) for request bodies.
- Sanitize outputs to prevent reflected XSS where applicable.
- Apply principle of least privilege to data returned in responses.

## Cross-Origin & CSRF

- CORS: restrict origins to trusted clients; avoid wildcard `*` for credentials-bearing endpoints.
- CSRF: for browser-based APIs, use same-site cookies or CSRF tokens (APIs using tokens in Authorization header are less vulnerable).
- Use SameSite cookie attribute and secure/HTTPOnly flags.

## Web Application Firewall (WAF) & API Gateway

- Place APIs behind an API Gateway (Kong, AWS API Gateway, GCP Endpoints, Apigee, Envoy) to centralize auth, rate-limiting, quotas, and logging.
- Use WAF (Cloudflare, AWS WAF, ModSecurity) to block common attack patterns (SQLi, XSS, bad bots).
- Gateways simplify applying global security policies (CORS, TLS, throttling).

## Secrets & Key Management

- Never store secrets in source code or unencrypted config.
- Use a secrets manager: AWS Secrets Manager, HashiCorp Vault, GCP Secret Manager.
- Rotate keys regularly and enforce least privilege.
- Use hardware-backed keys (HSM) for high-value credentials where possible.

## JWT & Token Best Practices

- Use short-lived access tokens and validate audience (aud), issuer (iss), and expiration (exp).
- Keep token payloads minimal — do not store sensitive data in JWT body.
- Consider token revocation strategy (maintain a token blacklist or use reference tokens).
- Validate tokens against signature and revocation lists in high-security contexts.

---

Short summary: Rate limiting should be scoped (user/API-key better than IP-only), use a suitable algorithm (token bucket for burst support), store counters atomically when distributed (Redis), integrate limits in your gateway, log and alert on rate-limit events, and include authentication, TLS, input validation, and testing as complementary controls.