
# 🎯 Important Design Patterns — Interview Notes (with Examples)

## 🧩 1. Singleton Pattern
Ensures only **one instance** of a class exists in the entire application.

### Example:
```js
class Singleton {
  constructor() {
    if (Singleton.instance) return Singleton.instance;
    this.config = { env: "dev" };
    Singleton.instance = this;
  }
}

const obj1 = new Singleton();
const obj2 = new Singleton();
console.log(obj1 === obj2); // true
```
**Use Case:** DB connection, Logger, Config

---

## 🏭 2. Factory Pattern
Provides a centralized way to **create objects without exposing instantiation logic**.

### Example:
```js
class DBFactory {
  static createConnection(type) {
    switch (type) {
      case "mysql": return { connect: () => console.log("MySQL connected") };
      case "oracle": return { connect: () => console.log("Oracle connected") };
      default: throw new Error("Unsupported DB");
    }
  }
}

const db = DBFactory.createConnection("oracle");
db.connect();
```
**Use Case:** Database Adapters, Payment Gateways

---

## 🏢 3. Abstract Factory Pattern
**Factory of factories** — used to create families of related objects.

### Example:
```js
class OracleFactory {
  createConnection() { return "OracleConnection"; }
  createQueryBuilder() { return "OracleQueryBuilder"; }
}
class MySQLFactory {
  createConnection() { return "MySQLConnection"; }
  createQueryBuilder() { return "MySQLQueryBuilder"; }
}

function getFactory(dbType) {
  return dbType === "oracle" ? new OracleFactory() : new MySQLFactory();
}

const factory = getFactory("oracle");
console.log(factory.createConnection());
```
**Use Case:** Sequelize Dialects, UI Theme Factories

---

## ⚙️ 4. Builder Pattern
Step-by-step construction of complex objects.

### Example:
```js
class UserBuilder {
  constructor(name) { this.name = name; }
  setAge(age) { this.age = age; return this; }
  setEmail(email) { this.email = email; return this; }
  build() { return this; }
}

const user = new UserBuilder("Warun").setAge(28).setEmail("test@mail.com").build();
console.log(user);
```
**Use Case:** Query Builders, Config Objects

---

## 🔁 5. Prototype Pattern
Clone existing objects instead of creating new ones.

### Example:
```js
const car = {
  wheels: 4,
  start() { console.log("Car started"); }
};

const bmw = Object.create(car);
bmw.brand = "BMW";
bmw.start();
```
**Use Case:** Object cloning, caching patterns

---

## 🧱 6. Adapter Pattern
Allows incompatible interfaces to work together.

### Example:
```js
class OldLogger { log(msg) { console.log("Old:", msg); } }
class NewLogger { info(msg) { console.log("New:", msg); } }

class LoggerAdapter {
  constructor(newLogger) { this.newLogger = newLogger; }
  log(msg) { this.newLogger.info(msg); }
}

const logger = new LoggerAdapter(new NewLogger());
logger.log("Hello Adapter");
```
**Use Case:** Integrating 3rd-party APIs, Database Dialects

---

## 🧩 7. Decorator Pattern
Add new functionality dynamically **without modifying the original class**.

### Example:
```js
function withLogger(fn) {
  return function(...args) {
    console.log("Args:", args);
    const result = fn(...args);
    console.log("Result:", result);
    return result;
  };
}

function add(a, b) { return a + b; }
const loggedAdd = withLogger(add);
loggedAdd(2, 3);
```
**Use Case:** Middleware, Logging, Authorization

---

## 🔗 8. Proxy Pattern
Controls access to an object (adds validation, caching, or logging).

### Example:
```js
const api = {
  fetchData() { return "data"; }
};

const apiProxy = new Proxy(api, {
  get(target, prop) {
    console.log(`Accessing ${prop}`);
    return target[prop];
  }
});

apiProxy.fetchData();
```
**Use Case:** Caching, Rate Limiting

---

## 📦 9. Observer Pattern
When one object changes, all dependents are notified automatically.

### Example:
```js
class Subject {
  constructor() { this.observers = []; }
  subscribe(fn) { this.observers.push(fn); }
  notify(data) { this.observers.forEach(fn => fn(data)); }
}

const subject = new Subject();
subject.subscribe(data => console.log("Observer1:", data));
subject.subscribe(data => console.log("Observer2:", data));

subject.notify("Event triggered!");
```
**Use Case:** Event-driven systems, WebSocket updates

---

## 🔄 10. Strategy Pattern
Defines a family of algorithms, encapsulates each, and makes them interchangeable.

### Example:
```js
class PayByCard { pay() { console.log("Paid via Card"); } }
class PayByUPI { pay() { console.log("Paid via UPI"); } }

class PaymentContext {
  setStrategy(strategy) { this.strategy = strategy; }
  pay() { this.strategy.pay(); }
}

const payment = new PaymentContext();
payment.setStrategy(new PayByCard());
payment.pay();
```
**Use Case:** Authentication strategies, Payment processing

---

## 🔁 11. Middleware Pattern (Node.js Specific)
Functions execute sequentially, passing control to the next one.

### Example:
```js
function middleware1(req, res, next) {
  console.log("Auth check");
  next();
}
function middleware2(req, res, next) {
  console.log("Logging");
  next();
}

function run(req, res, middlewares) {
  let index = 0;
  function next() {
    const mw = middlewares[index++];
    if (mw) mw(req, res, next);
  }
  next();
}

run({}, {}, [middleware1, middleware2]);
```
**Use Case:** Express.js request pipeline

---

## 🧠 Summary Table

| Category | Pattern | Purpose |
|-----------|----------|----------|
| Creational | Singleton | One instance only |
| Creational | Factory | Create objects dynamically |
| Creational | Abstract Factory | Create related factories |
| Creational | Builder | Step-by-step construction |
| Creational | Prototype | Clone existing objects |
| Structural | Adapter | Bridge incompatible APIs |
| Structural | Decorator | Add functionality dynamically |
| Structural | Proxy | Control access to object |
| Behavioral | Observer | Publish/subscribe mechanism |
| Behavioral | Strategy | Select algorithm at runtime |
| Node.js Specific | Middleware | Sequential control flow |

---

## 🎤 Interview Summary
> “I’ve used Factory and Strategy patterns frequently in Node.js — for example, for database adapters or payment processing. I also applied Adapter and Template patterns while extending Sequelize for Oracle compatibility, ensuring extensibility and clean architecture.”
