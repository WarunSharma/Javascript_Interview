
# üß≠ Software Design Principles ‚Äî Interview Notes

## 1. What Are Design Principles?
Design principles are **guidelines** that help developers create **clean, maintainable, and scalable software**.  
They ensure your code is easy to understand, test, and extend without breaking existing functionality.

---

## 2. Core Principles (The ‚ÄúSOLID‚Äù Principles)

### üß© S ‚Äî **Single Responsibility Principle (SRP)**
> A class/module should have only **one reason to change**.

Each component should handle one job ‚Äî makes code modular and testable.

```js
// ‚ùå Violates SRP
class UserService {
  register(user) { /* business logic */ }
  sendEmail(user) { /* email logic */ }
}

// ‚úÖ Follows SRP
class UserService {
  register(user) { /* business logic */ }
}

class EmailService {
  sendEmail(user) { /* email logic */ }
}
```

---

### üß© O ‚Äî **Open/Closed Principle (OCP)**
> Software entities should be **open for extension**, but **closed for modification**.

You should be able to add new behavior without changing existing code.

```js
class Payment {
  pay() {}
}

class CreditCardPayment extends Payment {
  pay() { console.log("Paid via credit card"); }
}

class UpiPayment extends Payment {
  pay() { console.log("Paid via UPI"); }
}

function processPayment(paymentMethod) {
  paymentMethod.pay();
}

processPayment(new UpiPayment());
```

---

### üß© L ‚Äî **Liskov Substitution Principle (LSP)**
> Subclasses should be **substitutable** for their base classes.

```js
class Bird {
  fly() {}
}

class Sparrow extends Bird {
  fly() { console.log("Flying"); }
}

// ‚ùå Violates LSP
class Penguin extends Bird {
  fly() { throw new Error("Can't fly"); }
}
```

---

### üß© I ‚Äî **Interface Segregation Principle (ISP)**
> No client should be forced to depend on interfaces it does not use.

```js
// ‚ùå Bad
class Machine {
  print() {}
  scan() {}
  fax() {}
}

// ‚úÖ Good
class Printer { print() {} }
class Scanner { scan() {} }
```

---

### üß© D ‚Äî **Dependency Inversion Principle (DIP)**
> Depend on **abstractions**, not on **concrete implementations**.

```js
// ‚ùå Bad
class MySQLDatabase {
  save(data) { console.log("Saved to MySQL"); }
}
class UserService {
  constructor() {
    this.db = new MySQLDatabase();
  }
}

// ‚úÖ Good
class Database {
  save(data) {}
}
class MySQLDatabase extends Database {
  save(data) { console.log("Saved to MySQL"); }
}
class UserService {
  constructor(db) {
    this.db = db;
  }
}
```

---

## 3. Other Common Design Principles

### üß± DRY ‚Äî **Don‚Äôt Repeat Yourself**
> Avoid code duplication; extract reusable logic.

### ‚ö° KISS ‚Äî **Keep It Simple, Stupid**
> Simpler code is easier to debug, maintain, and extend.

### üö´ YAGNI ‚Äî **You Aren‚Äôt Gonna Need It**
> Don‚Äôt add features ‚Äújust in case.‚Äù Build only what‚Äôs required.

### üß© Composition Over Inheritance
> Prefer **composition** (using smaller objects together) instead of large class hierarchies.

### üß† Separation of Concerns
> Divide application logic into distinct layers/modules (Controller, Service, Repository).

### üß© High Cohesion, Low Coupling
> - **High Cohesion:** related logic lives together  
> - **Low Coupling:** modules depend minimally on each other  

---

## 4. Applying Principles to Projects

In the **Sequelize Oracle Compatibility** project:
- **SRP:** Each module (connection manager, query generator) had a single purpose.  
- **OCP:** Added Oracle support without modifying existing dialects.  
- **DIP:** Used abstract interfaces so code didn‚Äôt depend on specific DB.  
- **DRY:** Reused core Sequelize logic where possible.  
- **KISS:** Avoided over-engineering.

---

## 5. Interview Summary
> ‚ÄúI follow SOLID and other design principles to keep code modular and scalable. For example, in my Oracle dialect work, I applied Single Responsibility and Open/Closed principles to extend Sequelize cleanly. I also ensure DRY, KISS, and low coupling throughout my codebase.‚Äù
