
# Authentication + JWT + Cookies (Interview Notes)

## 1. What is Authentication?
- **Authentication** = verifying **who the user is**  
- **Authorization** = verifying **what they can access**  
- Common methods:  
  - Session-based auth (cookies + server memory/DB)  
  - Token-based auth (JWT, OAuth)  

---

## 2. Session vs Token-based Authentication

### 🔹 Session-based (Cookie + Server-side session)
- User logs in → server creates a **session entry** (stored in memory/DB).  
- Session ID stored in **browser cookie**.  
- On each request, cookie is sent → server looks up session → validates user.  

✅ Pros: Simple, secure if HTTPS, session invalidation possible.  
❌ Cons: Doesn’t scale well (server stores sessions, sticky sessions needed).  

---

### 🔹 Token-based (JWT)
- User logs in → server generates a **JWT** signed with secret/private key.  
- Token stored on client (cookie or localStorage).  
- On each request, token is sent in **Authorization header** or cookie.  
- Server validates signature → authenticates user (stateless, no DB lookup required).  

✅ Pros: Scalable (stateless), works across services (microservices).  
❌ Cons: If stolen, JWT is valid until expiry (no server-side revoke by default).  

---

## 3. JWT (JSON Web Token)

- **Format**: `header.payload.signature`  
  - Header: `{ "alg": "HS256", "typ": "JWT" }`  
  - Payload: `{ "userId": 123, "role": "admin", "exp": 1718892010 }`  
  - Signature: HMAC SHA256 of header+payload with secret  

- Example:
```js
// Encode
const jwt = require("jsonwebtoken");
const token = jwt.sign({ userId: 123 }, "secretKey", { expiresIn: "1h" });

// Decode/Verify
try {
  const decoded = jwt.verify(token, "secretKey");
  console.log(decoded.userId); // 123
} catch (err) {
  console.log("Invalid token");
}
```

---

## 4. JWT + Cookies (Best Practice)

- Store JWT in **HttpOnly Secure Cookies** (not localStorage) to prevent **XSS attacks**.  
- Use `SameSite=strict` to mitigate CSRF.  

Example with Express:
```js
const express = require("express");
const jwt = require("jsonwebtoken");
const cookieParser = require("cookie-parser");

const app = express();
app.use(cookieParser());

app.post("/login", (req, res) => {
  const user = { id: 1, name: "Alice" }; // Normally from DB
  const token = jwt.sign(user, "secretKey", { expiresIn: "1h" });

  res.cookie("authToken", token, {
    httpOnly: true,
    secure: true,
    sameSite: "strict"
  });
  res.json({ message: "Logged in" });
});

app.get("/profile", (req, res) => {
  const token = req.cookies.authToken;
  if (!token) return res.status(401).json({ error: "Unauthorized" });

  try {
    const user = jwt.verify(token, "secretKey");
    res.json({ profile: user });
  } catch {
    res.status(403).json({ error: "Invalid token" });
  }
});
```

---

## 5. Security Considerations
- Always use **HTTPS** → prevents token/cookie sniffing.  
- Use **short expiry tokens** + **refresh tokens**.  
- Store JWT in **HttpOnly cookies** (not localStorage) to prevent XSS.  
- Mitigate CSRF → use `SameSite`, CSRF tokens, or double-submit cookies.  
- Rotate secrets periodically.  

---

## 6. Quick Recap
- **Cookies + Sessions** → Server stores session → good for monolith apps.  
- **JWT** → Self-contained, stateless → good for APIs/microservices.  
- Best practice: **JWT + HttpOnly Secure Cookies + Refresh tokens**.  
